generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * Enums
 */
enum Role {
  USER
  ADMIN
  MODERATOR
}

enum Visibility {
  PUBLIC
  PRIVATE
  DRAFT
}

enum ReviewStatus {
  PUBLISHED
  PENDING
  REMOVED
}

/**
 * Models
 */
model User {
  id            String      @id @default(uuid())
  username      String      @unique
  email         String      @unique
  passwordHash  String?
  role          Role        @default(USER)
  isEmailVerified Boolean   @default(false)
  bio           String?     @db.Text
  avatarUrl     String?
  website       String?
  settings      Json?
  isActive      Boolean     @default(true)
  lastSeen      DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // relations
  books         Book[]      @relation("UserBooks")
  notes         Note[]
  reviews       Review[]
  collections   Collection[]
  attachments   Attachment[]
  accounts      Account[]
  sessions      Session[]
  tags          Tag[]
  reviewReactions ReviewReaction[]
  noteReactions   NoteReaction[]
  notifications   Notification[]

  @@index([username])
  @@index([email])
}

model Book {
  id            String       @id @default(uuid())
  slug          String       @unique
  title         String
  subtitle      String?
  author        String
  isbn          String?      @unique
  description   String?      @db.Text
  coverUrl      String?
  pages         Int?
  language      String?
  publisher     String?
  publishedDate DateTime?
  addedAt       DateTime     @default(now())
  addedById     String?
  addedBy       User?        @relation("UserBooks", fields: [addedById], references: [id], onDelete: SetNull)
  reviews       Review[]
  notes         Note[]
  tags          BookTag[]
  attachments   Attachment[]
  avgRating     Float?
  ratingsCount  Int          @default(0)
  visibility    Visibility   @default(PUBLIC)
  externalUrl   String?
  deletedAt     DateTime?
  collectionItems CollectionItem[]

  @@index([title])
  @@index([author])
  @@index([addedAt])
}

model Review {
  id          String       @id @default(uuid())
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  book        Book         @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId      String
  rating      Int
  comment     String?      @db.Text
  status      ReviewStatus @default(PUBLISHED)
  helpfulCount Int         @default(0)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?

  reactions   ReviewReaction[]

  @@index([bookId, rating])
  @@index([userId])
}

model Note {
  id          String      @id @default(uuid())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  book        Book?       @relation(fields: [bookId], references: [id], onDelete: SetNull)
  bookId      String?
  title       String?
  content     String?     @db.Text
  contentJSON Json?
  color       String?
  topic       String?
  isPublic    Boolean     @default(false)
  isPinned    Boolean     @default(false)
  isArchived  Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?

  tags        NoteTag[]
  backlinksFrom NoteLink[] @relation("OutgoingLinks")
  backlinksTo   NoteLink[] @relation("IncomingLinks")
  attachments Attachment[]
  collectionItems CollectionItem[]
  reactions   NoteReaction[]

  @@index([userId, updatedAt])
  @@index([bookId])
}

model Tag {
  id       String   @id @default(uuid())
  name     String
  slug     String
  userId   String?
  user     User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  notes    NoteTag[]
  books    BookTag[]

  @@unique([userId, name])
  @@index([slug])
}

model NoteTag {
  id     String @id @default(uuid())
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)
  noteId String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId  String

  @@unique([noteId, tagId])
}

model BookTag {
  id     String @id @default(uuid())
  book   Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId  String

  @@unique([bookId, tagId])
}

model Collection {
  id         String           @id @default(uuid())
  user       User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  title      String
  description String?
  isPublic   Boolean          @default(false)
  items      CollectionItem[]
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  @@index([userId])
}

model CollectionItem {
  id           String     @id @default(uuid())
  collection   Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  collectionId String
  book         Book?      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId       String?
  note         Note?      @relation(fields: [noteId], references: [id], onDelete: Cascade)
  noteId       String?
  position     Int        @default(0)
  addedAt      DateTime   @default(now())

  @@index([collectionId, position])
}

model NoteLink {
  id     String @id @default(uuid())
  from   Note   @relation("OutgoingLinks", fields: [fromId], references: [id], onDelete: Cascade)
  fromId String
  to     Note   @relation("IncomingLinks", fields: [toId], references: [id], onDelete: Cascade)
  toId   String
  createdAt DateTime @default(now())

  @@unique([fromId, toId])
}

model Attachment {
  id          String   @id @default(uuid())
  url         String
  key         String?
  provider    String
  uploadedBy  User?     @relation(fields: [uploadedById], references: [id], onDelete: SetNull)
  uploadedById String?
  book        Book?     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  bookId      String?
  note        Note?     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  noteId      String?
  mime        String?
  size        Int?
  createdAt   DateTime  @default(now())

  @@index([uploadedById])
}

model ReviewReaction {
  id        String   @id @default(uuid())
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  reviewId  String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      String
  createdAt DateTime @default(now())
}

model NoteReaction {
  id       String   @id @default(uuid())
  note     Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  noteId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId   String
  type     String
  createdAt DateTime @default(now())
}

model Notification {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  title     String
  body      String?  @db.Text
  data      Json?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  deliveredAt DateTime?
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
